using System;
using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

namespace PracticeProject
{
    public enum UnitType { InfintryVehikle, ReconVehicle, Tank };
    public enum UnitStateType { Move, Fire, MoveAndFire, Waiting, SkippingStep };
    public enum ImpactType { ForestStaticImpact };
    public enum TerrainType { Plain, Forest };
    public enum Team { Green, Red, Blue };

    public class GlobalController : MonoBehaviour
    {
        public List<GameObject> unitList; // список 
        public List<GameObject> selectedList; // спиков выделенных объектов
        public Team playerArmy;
    }
    public static class TacticControler
    {
        internal static double Distance(GameObject unitX, GameObject unitY)
        {
            return Math.Sqrt(
                Math.Pow((unitX.transform.position.x - unitY.transform.position.x), 2) +
                Math.Pow((unitX.transform.position.y - unitY.transform.position.y), 2) +
                Math.Pow((unitX.transform.position.z - unitY.transform.position.z), 2)
                );
        }
        internal static double Distance(Vector3 A, Vector3 B)
        {
            return Math.Sqrt(
                Math.Pow((A.x - B.x), 2) +
                Math.Pow((A.y - B.y), 2) +
                Math.Pow((A.z - B.z), 2)
                );
        }
    }

    public class MovementController
    {
        private GameObject walker;
        private Vector3 moveDestination;
        public int backCount;
        public MovementController(GameObject walker)
        {
            this.walker = walker;
            moveDestination = walker.transform.position;
            walker.GetComponent<NavMeshAgent>().speed = walker.GetComponent<Unit>().speed;
            walker.GetComponent<NavMeshAgent>().acceleration = walker.GetComponent<Unit>().speed * 1.6f;
            walker.GetComponent<NavMeshAgent>().angularSpeed = walker.GetComponent<Unit>().speed * 5.3f;
        }
        public bool MoveTo(Vector3 destination)
        {
            moveDestination = destination;
            walker.GetComponent<NavMeshAgent>().SetDestination(moveDestination);
            backCount = 100;            
            return false;
        }
        public void Update()
        {
            if (TacticControler.Distance(walker.transform.position, moveDestination) < 3)
                {
                    //Debug.Log("Distanse " + TacticControler.Distance(walker.transform.position, moveDestination)+" Stop.");
                    //walker.GetComponent<NavMeshAgent>().Stop();
                }
            if (backCount == 0)
            {
                walker.GetComponent<NavMeshAgent>().SetDestination(moveDestination);
                backCount = 100;
            }
            else backCount--;
        }
        private double GetAngel(Vector3 A, Vector3 B)
        {
            return Math.Acos((A.x * B.x + A.y * B.y + A.z * B.z) / ((Math.Sqrt(A.x * A.x + A.y * A.y + A.z * A.z) * Math.Sqrt(B.x * B.x + B.y * B.y + B.z * B.z))));
        }
        //public bool MoveTo(Vector3 destination)
        //{
        //    State = MovementState.Stering;
        //    destination.y = 0;
        //    dirAngel = GetAngel(walker.transform.ro)
        //    backCount = 1;
        //    walker.GetComponent<Unit>().state = UnitStateType.Move;

        //    return false;
        //}
        //public void Update()
        //{
        //    switch (State)
        //    {
        //        case MovementState.Acceleration:
        //            {
        //                if (backCount > 0)
        //                {
        //                    //Debug.Log("Breaking");
        //                    //walker.GetComponent<Unit>().state = UnitStateType.Waiting;
        //                    //walker.GetComponent<Rigidbody>().AddForce(-moveDirection, ForceMode.VelocityChange);
        //                    backCount--;
        //                }
        //                else
        //                {
        //                    walker.GetComponent<Rigidbody>().AddForce(-Vector3.forward * walker.GetComponent<Unit>().speed, ForceMode.Acceleration);
        //                    State = MovementState.Breaking;
        //                    backCount = 100;
        //                }
        //                break;
        //            }
        //        case MovementState.Breaking:
        //            {
        //                if (backCount > 0)
        //                {
        //                    backCount--;
        //                }
        //                else
        //                {
        //                    State = MovementState.Rest;
        //                }
        //                break;
        //            }
        //        case MovementState.Stering:
        //            {
        //                if (backCount > 0)
        //                {
        //                    var target = walker.transform.position - rotDirection;
        //                    target.y = 0;
        //                    walker.transform.rotation = Quaternion.LookRotation(target, Vector3.up);
        //                    backCount--;
        //                }
        //                else
        //                {
        //                    walker.GetComponent<Rigidbody>().AddForce(Vector3.forward * walker.GetComponent<Unit>().speed, ForceMode.Acceleration);
        //                    State = MovementState.Acceleration;
        //                    backCount = 100;
        //                }
        //                break;
        //            }
        //        case MovementState.Rest:
        //            {
        //                if (backCount > 0)
        //                {
        //                    backCount--;
        //                }
        //                else
        //                {

        //                }
        //                break;
        //            }
        //    }
        //}
        //private double GetAngel(Vector3 A, Vector3 B)
        //{
        //    return Math.Acos((A.x * B.x + A.y * B.y + A.z * B.z) / ((Math.Sqrt(A.x * A.x + A.y * A.y + A.z * A.z) * Math.Sqrt(B.x * B.x + B.y * B.y + B.z * B.z))));
        //}
    }
    public class ShootController
    {
        public int backCount;
        public bool ShootHim(Unit shooter, Unit target)
        {
            return false;
        }
        public void Update()
        {
            backCount--;
        }
    }

    //public static class ObjectCreator
    //{
    //    public static Unit RestoreUnit(UnitType type, UnityEngine.Object GraficUnitRef)
    //    {
    //        string StatPath = type.ToString("F") + ".stat.dat";
    //        string[] stats = System.IO.File.ReadAllLines(StatPath);
    //        Unit newUnit = new Unit(
    //            Convert.ToInt32(stats[1]),
    //            Convert.ToInt32(stats[2]),
    //            Convert.ToDouble(stats[3]),
    //            Convert.ToDouble(stats[4]),
    //            Convert.ToInt32(stats[5]),
    //            Convert.ToInt32(stats[6]),
    //            Convert.ToInt32(stats[7]),
    //            Convert.ToInt32(stats[8]));
    //        newUnit.type = type;
    //        return newUnit;
    //    }
    //}
    public static class Randomizer
    {
        public static double[] Uniform(int minValue, int maxValue, int Count)
        {
            double[] Out = new double[Count];
            for (int i = 0; i < Count; i++)
            {
                Out[i] = Uniform(minValue, maxValue);
            }
            return Out;
        }
        public static double[] Exponential(double Rate, int Count, int minValue, int maxValue)
        {
            double[] stairWidth = new double[257];
            double[] stairHeight = new double[256];
            const double x1 = 7.69711747013104972;
            const double A = 3.9496598225815571993e-3; /// area under rectangle

            setupExpTables(ref stairWidth, ref stairHeight, x1, A);

            double[] Out = new double[Count];
            for (int i = 0; i < Count; i++)
            {
                Out[i] = Exponential(Rate, stairWidth, stairHeight, x1, minValue, maxValue);
            }

            return Out;
        }
        public static double[] Normal(double Mu, double Sigma, int Count, int minValue, int maxValue)
        {
            double[] stairWidth = new double[257];
            double[] stairHeight = new double[256];
            const double x1 = 3.6541528853610088;
            const double A = 4.92867323399e-3; /// area under rectangle

            setupNormalTables(ref stairWidth, ref stairHeight, x1, A);

            double[] Out = new double[Count];
            for (int i = 0; i < Count; i++)
            {
                Out[i] = Mu + NormalZiggurat(stairWidth, stairHeight, x1, minValue, maxValue) * Sigma;
            }

            return Out;
        }

        private static double Uniform(double A, double B)
        {
            return A + RandomDouble() * (B - A);// maxValue;
        }
        private static double MagiсUniform(double A, double B)
        {
            return A + RandomMagiсInt() * (B - A) / 256;
        }

        private static void setupExpTables(ref double[] stairWidth, ref double[] stairHeight, double x1, double A)
        {
            // coordinates of the implicit rectangle in base layer
            stairHeight[0] = Math.Exp(-x1);
            stairWidth[0] = A / stairHeight[0];
            // implicit value for the top layer
            stairWidth[256] = 0;
            for (int i = 1; i <= 255; ++i)
            {
                // such x_i that f(x_i) = y_{i-1}
                stairWidth[i] = -Math.Log(stairHeight[i - 1]);
                stairHeight[i] = stairHeight[i - 1] + A / stairWidth[i];
            }
        }
        private static void setupNormalTables(ref double[] stairWidth, ref double[] stairHeight, double x1, double A)
        {
            // coordinates of the implicit rectangle in base layer
            stairHeight[0] = Math.Exp(-.5 * x1 * x1);
            stairWidth[0] = A / stairHeight[0];
            // implicit value for the top layer
            stairWidth[256] = 0;
            for (int i = 1; i <= 255; ++i)
            {
                // such x_i that f(x_i) = y_{i-1}
                stairWidth[i] = Math.Sqrt(-2 * Math.Log(stairHeight[i - 1]));
                stairHeight[i] = stairHeight[i - 1] + A / stairWidth[i];
            }
        }

        private static double ExpZiggurat(double[] stairWidth, double[] stairHeight, double x1, int minValue, int maxValue)
        {
            int iter = 0;
            do
            {
                int stairId = RandomInt() & 255;
                double x = Uniform(0, stairWidth[stairId]); // get horizontal coordinate
                if (x < stairWidth[stairId + 1]) /// if we are under the upper stair - accept
                    return x;
                if (stairId == 0) // if we catch the tail
                    return x1 + ExpZiggurat(stairWidth, stairHeight, x1, minValue, maxValue);
                if (Uniform(stairHeight[stairId - 1], stairHeight[stairId]) < Math.Exp(-x)) // if we are under the curve - accept
                    return x;
                // rejection - go back
            } while (++iter <= 1e9); // one billion should be enough to be sure there is a bug
            return double.NaN; // fail due to some error
        }
        private static double NormalZiggurat(double[] stairWidth, double[] stairHeight, double x1, int minValue, int maxValue)
        {
            int iter = 0;
            do
            {
                int B = RandomMagiсInt();
                int stairId = B & 255;
                double x = MagiсUniform(0, stairWidth[stairId]); // get horizontal coordinate
                if (x < stairWidth[stairId + 1])
                    return ((int)B > 0) ? x : -x;
                if (stairId == 0) // handle the base layer
                {
                    double z = -1;
                    double y;
                    if (z > 0) // we don't have to generate another exponential variable as we already have one
                    {
                        x = Exponential(x1, stairWidth, stairHeight, x1, minValue, maxValue);
                        z -= 0.5 * x * x;
                    }
                    if (z <= 0) // if previous generation wasn't successful
                    {
                        do
                        {
                            x = Exponential(x1, stairWidth, stairHeight, x1, minValue, maxValue);
                            y = Exponential(1, stairWidth, stairHeight, x1, minValue, maxValue);
                            z = y - 0.5 * x * x; // we storage this value as after acceptance it becomes exponentially distributed
                        } while (z <= 0);
                    }
                    x += x1;
                    return ((int)B > 0) ? x : -x;
                }
                // handle the wedges of other stairs
                if (MagiсUniform(stairHeight[stairId - 1], stairHeight[stairId]) < Math.Exp(-.5 * x * x))
                    return ((int)B > 0) ? x : -x;
            } while (++iter <= 1e9); /// one billion should be enough
            return double.NaN; /// fail due to some error
        }
        private static double Exponential(double Rate, double[] stairWidth, double[] stairHeight, double x1, int minValue, int maxValue)
        {
            return ExpZiggurat(stairWidth, stairHeight, x1, minValue, maxValue) / Rate;
        }
        private static double RandomDouble()
        {
            System.Security.Cryptography.RNGCryptoServiceProvider rand = new System.Security.Cryptography.RNGCryptoServiceProvider();
            const int BUF_LENGTH = 1;
            byte[] buf = new byte[BUF_LENGTH];
            rand.GetBytes(buf);
            double Out = 0;
            foreach (byte x in buf)
                Out += x / 256.0;
            return Out;
        }
        private static int RandomInt()
        {
            System.Security.Cryptography.RNGCryptoServiceProvider rand = new System.Security.Cryptography.RNGCryptoServiceProvider();
            const int BUF_LENGTH = 1;
            byte[] buf = new byte[BUF_LENGTH];
            rand.GetBytes(buf);
            int Out = 0;
            foreach (byte x in buf)
                Out += x;
            return Out / BUF_LENGTH;
        }
        private static int RandomMagiсInt()
        {
            System.Security.Cryptography.RNGCryptoServiceProvider rand = new System.Security.Cryptography.RNGCryptoServiceProvider();
            const int BUF_LENGTH = 256;
            byte[] buf = new byte[BUF_LENGTH];
            rand.GetBytes(buf);
            int Out = 0;
            foreach (byte x in buf)
                Out += x;
            return Out / BUF_LENGTH;
        }
    }
}
